[{"content":"","date":"29 May 2023","permalink":"/","section":"","summary":"","title":""},{"content":"","date":"29 May 2023","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"29 May 2023","permalink":"/tags/code-analysis/","section":"Tags","summary":"","title":"Code Analysis"},{"content":"","date":"29 May 2023","permalink":"/categories/code-analysis/","section":"Categories","summary":"","title":"Code Analysis"},{"content":" futtop.c # Entrance of the whole program, and includes fellow functions:\nSetup OpenMP and futhark backends (Multicore, OpenCL or CUDA). Setup models (Cantilever, MBB Beam) by calculating Vertices, Nodal Force, etc . Setup variables (Force, Displacement, Density, etc) about optimization. Run following Construct Multigrid, Slove State System (K$\\mu$ = f), Compute New $x$, Get New Density. ","date":"29 May 2023","permalink":"/posts/topopt-futtop/code-analysis-topopt-futtop/","section":"Posts","summary":"","title":"Code Analysis topopt-futtop"},{"content":"","date":"29 May 2023","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"29 May 2023","permalink":"/tags/program/","section":"Tags","summary":"","title":"Program"},{"content":"","date":"29 May 2023","permalink":"/categories/program/","section":"Categories","summary":"","title":"Program"},{"content":"","date":"29 May 2023","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"29 May 2023","permalink":"/tags/topopt-futtop/","section":"Tags","summary":"","title":"topopt-futtop"},{"content":"","date":"23 May 2023","permalink":"/tags/elasticity/","section":"Tags","summary":"","title":"Elasticity"},{"content":"","date":"23 May 2023","permalink":"/categories/elasticity/","section":"Categories","summary":"","title":"Elasticity"},{"content":"","date":"23 May 2023","permalink":"/tags/optimization/","section":"Tags","summary":"","title":"Optimization"},{"content":"","date":"23 May 2023","permalink":"/categories/optimization/","section":"Categories","summary":"","title":"Optimization"},{"content":"","date":"23 May 2023","permalink":"/tags/theory/","section":"Tags","summary":"","title":"Theory"},{"content":"","date":"23 May 2023","permalink":"/categories/theory/","section":"Categories","summary":"","title":"Theory"},{"content":"Items: Stress, Stress tensor, Strain, Strain tensor, Strain energy, Elastic deformation, Plastic deformation, Small strain linear elasticity, Elastic modulus (or Young\u0026rsquo;s modulus), Strain energy density, Lamé parameters.\nStress # Stress is the distribution of internal forces per unit area within a material, usually represented by the symbol $\\sigma$. The unit of stress is Pascal ($Pa$), which is equal to Newton per square meter ($N/m^{2}$). The equation for stress can be expressed as\n$$\\sigma = \\frac{F}{A}$$\nwhere $F$ represents the force applied to the object in Newtons ($N$) or kilonewtons ($kN$) and $A$ represents the area of the object subjected to the force in square meters ($m^{2}$) or square centimeters ($cm^{2}$).\nStress is a measure of the deformation or strain that occurs in a material when subjected to external forces. In materials science and engineering, stress is an important parameter used for designing and analyzing the strength and stability of various structures and mechanical components.\nThere are different types of stress, including tensile stress, compressive stress, and shear stress. Tensile stress is the stress that occurs in a material when it is pulled or stretched, while compressive stress is the stress that occurs when it is compressed or squeezed. Shear stress is the stress that results from the relative sliding between the molecular planes of a material, commonly observed in cutting operations and shearing forces.\nThe magnitude and direction of stress have significant effects on the strength and deformation of a material. If the stress exceeds the ultimate strength of a material, it will fail or break. Therefore, stress analysis is a critical part of engineering design to ensure the safety and reliability of structures and mechanical components.\nStress tensor # Stress tensor is a mathematical object used to describe the state of stress to which a solid is subjected internally. It is a second-order tensor containing nine components representing the positive and shear stresses in three coordinate directions. In three-dimensional space, the stress tensor can be represented as a $3\\times3$ matrix as follows\n$$ \\epsilon = \\begin{bmatrix} \\sigma_{xx} \u0026amp; sigma_{xy} \u0026amp; sigma_{xz} \\ \\sigma_{yx} \u0026amp; sigma_{yy} \u0026amp; sigma_{yz} \\ \\sigma_{zx} \u0026amp; sigma_{zy} \u0026amp; sigma_{zz} \\end{bmatrix} $$\nwhere $\\sigma_{ij}$ indicates that the stress component in the $i$-th coordinate direction is caused by the stress in the $j$-th coordinate direction. The symmetry of the stress tensor indicates the equilibrium of the forces, i.e., the sum of the tangential stresses in any plane is zero.\nIn two dimensions, the stress tensor is represented by a $2\\times2$ symmetric matrix, and its components are denoted by $\\sigma_{xx}$, $\\sigma_{yy}$, $\\sigma_{xy}$, and $\\sigma_{yx}$.\nThe stress tensor in two dimensions can be written as:\n$$ \\epsilon = \\begin{bmatrix} \\sigma_{xx} \u0026amp; sigma_{xy} \\ \\sigma_{yx} \u0026amp; sigma_{yy} \\ \\end{bmatrix} $$\nwhere $\\sigma_{xx}$ and $\\sigma_{yy}$ are the normal stresses acting on the $x$ and y planes, respectively, $\\sigma_{xy}$, and $\\sigma_{yx}$ is the shear stress acting on the $xy$ plane.\nThe stress tensor can be solved by applying an external force to an object and then measuring the stress inside the object. It is an important concept in the fields of elastodynamics, mechanics of materials, solid mechanics, and fluid mechanics. The stress tensor can also be used to calculate the strain tensor, which describes the deformation within a solid.\nStrain # Strain is the degree of deformation of an object under the action of an external force and is usually expressed as ε. Strain can be divided into different types, including linear strain, shear strain, and volume strain, etc. Each type of strain has different calculation formulae.\nLinear or axial strain Linear strain refers to the degree of deformation of an object when it is stretched or compressed in a certain direction. The formula for calculating linear strain is\n$$ \\epsilon = \\frac{\\Delta L}{L_{0}}$$\nwhere $\\epsilon$ represents the linear strain, $\\Delta L$ represents the amount of change in the length of the object, and $L_{0}$ represents the original length of the object.\nShear strain Shear strain is the degree of deformation that occurs when an object is subjected to a cutting force. The formula for calculating shear strain is\n$$\\gamma = \\frac{\\Delta x}{h}$$\nwhere $\\gamma$ is the shear strain, $\\Delta x$ is the displacement of the object shear, and $h$ is the thickness of the object shear surface.\nVolumetric strain Volumetric strain is the degree of change in the overall volume of an object when subjected to an external force. The formula for calculating the volumetric strain is\n$$ \\epsilon_{v} = \\frac{\\Delta V}{V_{0}}$$\nwhere $\\epsilon_{v}$ denotes the volume strain, $\\Delta V$ denotes the amount of change in the volume of the object, and $V_{0}$ denotes the original volume of the object.\nThe appropriate strain formula needs to be selected for the calculation according to the specific type of strain and the deformation of the object. Different types of strains have different importance and uses in different mechanical and engineering applications.\nStrain tensor # Strain tensor is a mathematical object that describes the deformation of a solid body in response to an applied stress. It is a second-order tensor, meaning it has both magnitude and direction.\nThe strain tensor is defined as the relative change in length between two infinitesimally close points within the body in response to an applied stress. It can be expressed as a matrix of six components in three dimensions, or as a vector in two dimensions.\nIn three dimensions, the strain tensor can be represented as:\n$$ \\epsilon = \\begin{bmatrix} \\epsilon_{xx} \u0026amp; epsilon_{xy} \u0026amp; epsilon_{xz} \\ \\epsilon_{yx} \u0026amp; epsilon_{yy} \u0026amp; epsilon_{yz} \\ \\epsilon_{zx} \u0026amp; epsilon_{zy} \u0026amp; epsilon_{zz} \\end{bmatrix} $$\nwhere $\\epsilon_{ij}$ represents the strain in the $i-th$ direction caused by a stress in the $j-th$ direction.\nIn two dimensions, the strain tensor can be represented as: $$ \\epsilon = \\begin{bmatrix} \\epsilon_{xx} \u0026amp; epsilon_{xy} \\ \\epsilon_{yx} \u0026amp; epsilon_{yy} \\ \\end{bmatrix} $$ where $\\epsilon_{xx}$ and $\\epsilon_{yy}$ represent the strains in the $x$- and $y$-directions, respectively, $\\epsilon_{xy}$ and $\\epsilon_{yx}$ represents the shear strain.\nThe strain tensor is an important quantity in solid mechanics, as it is used to calculate the stress tensor, which describes the distribution of stresses within the body. The strain tensor can also be used to calculate other mechanical properties of the material, such as the elastic modulus and Poisson\u0026rsquo;s ratio.\nStrain energy # **Strain energy **is the energy stored inside an object due to stress. Under stress, an object is deformed, which leads to the accumulation of deformation energy inside the object. Strain energy is usually expressed in mathematical form as the volume integral of an object, and it is an important parameter to describe the elastic behavior of an object.\nThe magnitude of the strain energy depends on the shape and size of the object, the material properties and the force applied to the object. When the applied force exceeds the elastic limit of the object, the strain energy will be released, resulting in plastic deformation or destruction of the object. Therefore, strain energy is an important indicator to assess whether an object has sufficient strength and stability under force.\nIn engineering design and structural optimization, strain energy is often used as a design objective or optimization indicator. For example, when designing automotive structures, strain energy can be used to optimize the stiffness and weight of a vehicle frame. When designing mechanical parts, strain energy can be used to optimize the material use and weight reduction of the part. By optimizing strain energy, more efficient, reliable and economical designs can be achieved.\nElastic deformation \u0026amp; Plastic deformation # Elastic deformation refers to the reversible deformation of a material when subjected to stress. That is, when external forces are removed, the object can return to its original shape. Elastic deformation typically occurs when the applied stress is below the elastic limit of the material.\nPlastic deformation refers to the irreversible deformation of a material when subjected to stress. Unlike elastic deformation, plastic deformation does not return to its original shape when the external forces are removed. Plastic deformation typically occurs when the applied stress exceeds the elastic limit of the material. When a material is subjected to sufficiently large stresses, the atoms or molecules within it will begin to move and deform until they reach a new equilibrium position. This results in permanent changes to the shape and volume of the material.\nSmall strain linear elasticity # Small strain linear elasticity is a branch of continuum mechanics that deals with the behavior of materials under small deformations or strains. In this framework, it is assumed that the deformation is sufficiently small such that the relationship between stress and strain can be approximated as linear, meaning that the deformation is proportional to the applied stress and returns to its original shape when the stress is removed. This linear relationship is described by Hooke\u0026rsquo;s law, which states that the stress is proportional to the strain.\nMathematically, this relationship can be expressed as $\\sigma = C \\epsilon$, where $\\sigma$ is the stress tensor, $\\epsilon$ is the strain tensor, and $C$ is the fourth-order elastic stiffness tensor. The stiffness tensor contains information about the material properties and can be determined experimentally or theoretically.\nThe small strain assumption means that the magnitude of the deformation is much smaller than the size of the object being deformed. This assumption allows for simplifications in mathematical computations and is valid for most engineering applications, including the design of structures and machines, the analysis of geological formations, and the development of new materials. It is an important tool for understanding the mechanical behavior of materials and predicting their response to external loads.\nElastic modulus (or Young\u0026rsquo;s modulus) # Elastic modulus is a measure of the stiffness or elasticity of a material, usually denoted by the symbol $E$. Elastic modulus is given by\n$$E = \\frac{\\sigma}{\\epsilon}$$\nwhere E denotes the modulus of elasticity in pascals ($Pa$) or kilopascals ($kPa$); $\\sigma$ denotes the stress in pascals; and $\\epsilon$ denotes the strain, unitless.\nElastic modulus is the ratio of the elastic deformation of a material to the area subjected to an external force. It is the ratio of the degree of elastic deformation produced by a material when subjected to an external force to the area subjected to the force, and can also be expressed as the amount of elastic energy stored per unit volume. The higher the modulus of elasticity, the more difficult it is for the material to deform or distort, and the higher the stiffness.\nElastic modulus is commonly used to describe the elastic properties of various materials, including solids, liquids and gases. In solid materials, the modulus of elasticity can be used to calculate the relationship between stress and strain when a material is subjected to a force. It is an important parameter for the elastic behavior of materials and is of great importance for engineering design and material selection.\nElastic modulus of different materials can vary greatly, for example, the modulus of elasticity of steel is about $2.1\\times10^{11} Pa$, the modulus of elasticity of aluminum is about $7\\times10^{10} Pa$, and the modulus of elasticity of rubber is only about a few million $Pa$.\nElastic modulus can be measured by various experimental methods, such as tensile test, compression test and bending test. In engineering design, elastic modulus is often used to calculate and predict the deformation and damage behavior of materials under different loads to ensure that the designed structures and materials will meet the expected usage requirements.\nStrain energy density # Strain energy density is a measure of the amount of energy stored within a material per unit volume due to its deformation or strain. When a material is subjected to external forces, it undergoes deformation, and some of the energy of the system is stored within the material in the form of strain energy.\nThe strain energy density is represented by the symbol $u$ (sometimes also denoted by $W$) and is typically expressed in units of joules per cubic meter ($J/m^{3}$). It is calculated by dividing the strain energy of a material by its volume. The equation for the strain energy density is\n$$u = \\frac{1}{2} \\times σ \\times ε = \\frac{1}{2} \\times (E \\times \\epsilon^{2}) $$\nσ denotes the stress in pascals ($Pa$); and $\\epsilon$ denotes the strain, unitless, and $E$ denotes the modulus of elasticity of the object. The $\\frac{1}{2}$ in the formula is because the elastic potential energy is generated by the deformation in both directions, tensile and compressive, which are equal and therefore need to be averaged.\nStrain energy density plays an important role in determining the mechanical properties of materials, such as their stiffness, strength, and toughness. It is often used in engineering applications to design and analyze the behavior of materials under different loading conditions.\nFor example, in the design of a spring, the strain energy density is a key factor in determining the amount of deformation that the spring can undergo before reaching its maximum load capacity. By calculating the strain energy density, engineers can optimize the design of the spring to achieve the desired level of performance and reliability.\nDifferents between elastic modulus and strain energy density # Elastic modulus and strain energy density are both important parameters in the mechanics of materials, but they describe different material properties.\nElastic modulus (also known as the coefficient of elasticity) is a measure of the stiffness or elasticity of a material and is usually denoted by the symbol E. It is the ratio of the degree of elastic deformation produced by a material when subjected to an external force to the area subjected to the force, and can also be expressed as the amount of elastic energy stored per unit volume. The greater the modulus of elasticity, the more difficult it is for the material to deform or distort, and the higher the stiffness. The unit of modulus of elasticity is Pascal ($Pa$) or kilopascal ($kPa$).\nStrain energy density is the density of energy stored in the material during deformation, usually expressed by the symbol u. It is the ratio of strain energy to volume of the material in joules per cubic meter ($J/m^{3}$). When a material is subjected to an external force, it deforms and this deformation stores energy, which is recovered in the form of strain energy density to describe the process when the external force stops acting on the material. Strain energy density can be used to predict properties such as stability and strength of a material during deformation.\nAlthough both elastic modulus and strain energy density describe the mechanical properties of a material, they describe slightly different aspects. Elastic modulus is more concerned with the stiffness and elastic properties of a material, while strain energy density is more concerned with the energy storage and release properties of a material.\nLamé parameters # Lamé parameters, also known as Lamé coefficients, are two material constants that describe the elastic properties of a solid material. They are named after the French mathematician Gabriel Lamé who introduced them in the mid-19th century.\nThe two Lamé parameters are denoted by $\\lambda$ and $\\mu$, where $\\lambda$ is the first Lamé parameter (also known as the \u0026ldquo;Lamé constant\u0026rdquo; or \u0026ldquo;Lamé modulus\u0026rdquo;) and $\\mu$ is the second Lamé parameter (also known as the \u0026ldquo;shear modulus\u0026rdquo; or \u0026ldquo;rigidity modulus\u0026rdquo;).\nIn terms of these parameters, the stress tensor can be expressed as a function of the strain tensor using the linear elasticity equations. Specifically, for a linear elastic material, the stress tensor $\\sigma$ is related to the strain tensor $\\epsilon$ by the equation:\n$$\\sigma = \\lambda tr(\\epsilon) I + 2\\mu\\epsilon$$\nwhere $tr(\\epsilon)$ is the trace of the strain tensor (the sum of its diagonal elements), $I$ is the identity matrix, and $\\epsilon$ is the strain tensor.\nThe Lamé parameters are important in the study of elasticity, plasticity, and deformation of solids, and are used to characterize the mechanical behavior of materials under various loading conditions. They are typically determined experimentally and can vary significantly depending on the material composition and structure.\n","date":"23 May 2023","permalink":"/posts/theory-of-elasticity/theory-of-elasticity-note-1/","section":"Posts","summary":"\u003cp\u003e\u003cstrong\u003eItems\u003c/strong\u003e: Stress, Stress tensor, Strain, Strain tensor, Strain energy, Elastic deformation, Plastic deformation, Small strain linear elasticity, Elastic modulus (or Young\u0026rsquo;s modulus), Strain energy density,  Lamé parameters.\u003c/p\u003e","title":"Theory of Elasticity Note 1"},{"content":"Items: Compliance minimization, Density filtering, Volume constraint, Non-physical phenomena, Chequer-boarding, Stiffness interpolation, Solid Isotropic Material Penalisation (SIMP), Optimality Criteria (OC), Linear system, Matrix-free operator, Aassembly of coarse operators.\nCompliance minimization \u0026amp; Density filtering \u0026amp; Volume constraint # Compliance minimization with density filtering and a volume constraint is a problem commonly encountered in structural optimization. The goal is to design a structure that is both strong enough to withstand its intended loads and lightweight, to minimize material usage and cost.\nDensity filtering is a technique used to remove low-density elements from the design domain. The idea is to exclude regions with low material density that are unlikely to contribute significantly to the structural stiffness. This can help to reduce the overall weight of the structure.\nVolume constraint, on the other hand, places a limit on the total amount of material used in the design. This can be expressed as a percentage of the total volume of the structure or as a maximum allowable mass. The volume constraint ensures that the optimization process results in a design that is physically feasible and does not exceed the available resources.\nThe compliance minimization objective is to minimize the deformation or strain energy of the structure subject to the loads and boundary conditions. This objective function captures the overall stiffness of the structure, which is a key performance criterion for many engineering applications.\nTo solve this problem, various optimization techniques can be used, including gradient-based methods, evolutionary algorithms, and topology optimization methods. These methods can be combined with density filtering and volume constraints to generate designs that meet the desired specifications.\nIn summary, compliance minimization with density filtering and a volume constraint is a common problem in structural optimization that aims to design a lightweight and strong structure. The problem can be solved using various optimization techniques, including density filtering and volume constraints, to generate designs that meet the desired performance criteria while satisfying physical constraints.\nNon-physical phenomena \u0026amp; Chequer-boarding # Non-physical phenomena refers to the phenomena or effects that are not determined by physical factors when simulating or describing a physical system. These phenomena or effects are usually caused by numerical or algorithmic issues of the simulation or description method itself.\nChequer-boarding is a type of non-physical phenomenon that often occurs in computational fluid dynamics (CFD). It refers to the alternating high and low pressure regions appearing on the mesh points in the simulated flow field, which can be metaphorically compared to the black and white squares on a checkerboard. This phenomenon is typically caused by the instability and inappropriate mesh partition of numerical methods, resulting in the inaccuracy and unreliability of the simulation results.\nTo avoid non-physical phenomena like chequer-boarding, some improvements in numerical methods and mesh partition are usually required. For example, higher-order accuracy numerical methods, improved discretization schemes, finer mesh partition, and some smoothing techniques can be adopted to enhance the accuracy and reliability of the flow field simulation.\nDensity filtering is a commonly used technique in topology optimization that can partially address non-physical phenomena such as chequer-boarding. Density filtering can be understood as a smoothing operation on the design domain during the optimization process, which removes some geometric features that are unreasonable and produces a more rational design. In some cases, density filtering can reduce the occurrence of chequer-boarding by suppressing high-frequency oscillations.\nDensity filtering usually involves the concept of a filtering radius, which means that for a given element to be optimized, the density values of the neighboring elements within a certain radius are averaged to obtain the new density value of the element. By continually applying this smoothing operation, a smoother density distribution can be obtained, avoiding the appearance of some unreasonable geometric features. At the same time, due to the smoothing effect of this processing method, some high-frequency oscillations are also eliminated or weakened, thereby achieving the goal of reducing chequer-boarding.\nIt should be noted that the application of density filtering needs to be performed under appropriate circumstances, as excessive smoothing can also have adverse effects on optimization results. Therefore, in practical applications, the specific parameters and usage of density filtering need to be determined by considering factors such as optimization efficiency and computational efficiency.\nStiffness interpolation # Stiffness interpolation refers to a technique in finite element analysis where the stiffness matrix of an element is calculated based on the properties of its constituent materials. In stiffness interpolation, the element\u0026rsquo;s stiffness matrix is represented as a linear combination of the stiffness matrices of the constituent materials, weighted by their volume fractions within the element.\nStiffness interpolation is used in multiscale and multiphysics simulations, where the properties of materials may vary across different length scales or under different loading conditions. By using stiffness interpolation, the properties of each material within an element can be taken into account when calculating the overall stiffness matrix of the element. This allows for more accurate simulations of complex structures and materials.\nOne common approach for stiffness interpolation is the Voigt-Reuss-Hill (VRH) method, which represents the overall stiffness matrix of an element as the arithmetic or geometric mean of the stiffness matrices of its constituent materials. Other methods, such as the Mori-Tanaka method and the self-consistent method, may also be used depending on the specific requirements of the simulation.\nSolid Isotropic Material Penalisation (SIMP) # Solid Isotropic Material Penalisation (SIMP) is a numerical method commonly used in structural optimization. The basic idea is to use material density as the optimization variable to find the optimal material distribution that satisfies the given performance indicators and constraints.\nIn the SIMP method, the structure is divided into many small elements, and each element is assigned a material density that varies continuously between 0 and 1. During the optimization process, the optimization algorithm adjusts the density of each element to achieve the best structural performance. The SIMP method typically uses penalty functions to restrict the range of material densities between $0$ and $1$, thus constraining the material density. Therefore, a penalty function is needed to constrain the range of material density to avoid non-physical material density distributions.\nOne common penalty function is the Power Law Function, which is typically written as: $$ \\rho^{p} $$\nHere, $\\rho$ represents material density, and $p$ is a positive real number. When $p$ is larger, the penalty function has a more significant effect. This penalty function can constrain the values of material density between $0$ and $1$, avoiding non-physical material density distributions and improving the reliability of the optimization results.\nThe SIMP method also uses the equivalent Young\u0026rsquo;s modulus to represent the stiffness of the material. The equivalent Young\u0026rsquo;s modulus is a function of density that represents the effect of material density on stiffness. Typically, the equivalent Young\u0026rsquo;s modulus increases as material density increases, as higher density materials have higher stiffness.\nDuring the optimization process, the SIMP method calculates the equivalent Young\u0026rsquo;s modulus of the material and uses it to calculate the stiffness matrix of the entire structure. By considering the equivalent Young\u0026rsquo;s modulus of the material, the SIMP method can automatically consider the effect of the material\u0026rsquo;s topology on the stiffness of the structure.\nOne important application of the SIMP method is to achieve lightweight design in structural design. By using the SIMP method, the optimal material distribution can be found to minimize the total mass of the structure while satisfying the given performance indicators and constraints. The SIMP method has been widely used in structural optimization in aerospace, automotive, and mechanical engineering, and has been widely applied in material design.\nOptimality Criteria (OC) # Optimality Criteria (OC) method is a popular approach used in structural optimization for solving problems related to minimization of the weight or maximization of the stiffness of a structure subjected to certain constraints. In this method, the structure is discretized into finite elements, and the design variables are associated with the properties of these elements.\nThe OC method is based on the assumption that the optimal solution is achieved when certain optimality criteria are satisfied. These criteria are formulated as a set of nonlinear equations that are solved iteratively to obtain the optimal solution. The basic idea of the OC method is to reduce the compliance of the structure by modifying the properties of the finite elements in such a way that the optimality criteria are satisfied.\nThe OC method has several advantages, such as its simplicity and ability to handle problems with large numbers of design variables. However, it also has some limitations, such as its reliance on heuristics and the lack of a formal convergence analysis.\nIn recent years, several variations of the OC method have been proposed, such as the Bi-Directional Evolutionary Structural Optimization (BESO) and the Extended Optimality Criteria (EOC) method, which aim to overcome some of the limitations of the traditional OC method.\nLinear system # Linear system refers to a system of linear equations, where each equation is linear in its variables. In other words, the variables are raised only to the power of 1 and multiplied by constants. A linear system can be represented in matrix form as $Ax = b$, where A is the coefficient matrix, x is the vector of variables, and b is the vector of constants. Linear systems are commonly used in many fields, such as engineering, physics, economics, and computer science. They can be solved using various methods, such as Gaussian elimination, LU decomposition, and matrix inversion.\nMatrix-free operator # Matrix-free operator refers to a method for performing matrix-vector multiplication in which the explicit construction of the matrix is not required. Instead, the operator is defined by a set of algorithms or functions that compute the result of multiplying a given vector by the matrix without explicitly forming the matrix. This approach can be useful for large-scale problems where the storage and computation requirements of the matrix are prohibitive. Instead, only the necessary information to perform the matrix-vector multiplication is stored, leading to more efficient computations.\nAassembly of coarse operators # Aassembly of coarse operators is a fundamental step in the construction of multigrid methods, which are numerical algorithms used to solve large systems of equations arising from partial differential equations (PDEs). In particular, coarse operators play a crucial role in the process of transferring information between different levels of resolution within a multigrid hierarchy.\nThe assembly of coarse operators involves constructing a matrix that approximates the behavior of the fine-scale operator on a given coarse grid. This coarse operator matrix can then be used to solve the system of equations on the coarse grid more efficiently than solving the full system directly.\nThe construction of the coarse operator matrix typically involves two main steps: restriction and interpolation. The restriction step involves reducing the solution and right-hand sides of the fine-scale system to their corresponding counterparts on the coarse grid, while the interpolation step involves mapping the coarse-grid solution back to the fine grid. These steps require careful consideration of the underlying PDE and the chosen discretization scheme.\nIn summary, the assembly of coarse operators is a key component of multigrid methods for solving PDEs. It involves constructing a matrix that approximates the behavior of the fine-scale operator on a given coarse grid, using a combination of restriction and interpolation operations.\n","date":"23 May 2023","permalink":"/posts/topology-optimization/topology-optimization-note-1/","section":"Posts","summary":"\u003cp\u003e\u003cstrong\u003eItems\u003c/strong\u003e: Compliance minimization, Density filtering, Volume constraint, Non-physical phenomena, Chequer-boarding, Stiffness interpolation, Solid Isotropic Material Penalisation (SIMP), Optimality Criteria (OC), Linear system, Matrix-free operator, Aassembly of coarse operators.\u003c/p\u003e","title":"Topology Optimization Note 1"},{"content":"","date":"9 March 2023","permalink":"/categories/_misc/","section":"Categories","summary":"","title":"_Misc"},{"content":"This article will introduce the programming of C++20, mainly focus on the Differences between C++ early version and the C++20, also including some basic concepts of C++.\nTo read this article, you need prepare some basic programming knowledge of C++.\nBasic Programming # Importing Modules # C++20 uses import declaration end with ';' to instead of #include preprocessor directive in early version.\nimport \u0026lt;iostream\u0026gt;; //C++20 #include \u0026lt;iostream\u0026gt; //early version Preprocessor Directives # C++20 uses #pragma once to instead of #ifndef...#endif to avoid re-importing the same module.\n//C++20 #pragma once //... codes //early version #ifndef MYCODE #define MYCODE //..codes #endif Nested Namesapce # A nested namespace is a namespace inside another one. Each namespace is separated by a double colon. Here the difference after and before C++17\n//after C++17 namespace MyLibraries::Networking::FTP { /* ... */ } //early version namespace MyLibraries { namespace Networking { namespace FTP { /* ... */ } } } Namespace Alias # A namespace alias can be used to give a new and possibly shorter name to another namespace. Here’s an example:\nnamespace MyFTP = MyLibraries::Networking::FTP; Numeric literals # Digits separators can be used in numeric literals. A digits separator is a single quote character. For example:\n23\u0026#39;456\u0026#39;789 0.123\u0026#39;456f Variables # Uniform initialization '{}' was introduced with the C++11 standard instead of using assignment synatx '='.\nint v {7}; //C++11 int v = 7; //early version C++20 provides char8_t, char16_t, char32_t to represent A single n-bit UTF-n-encoded Unicode character where n can be 8, 16, or 32.\n*Before C++20 wchar_t was used to process Unicode character.\n//C++ char8_t c8 {u8\u0026#39;m\u0026#39;}; char16_t c16 {u\u0026#39;m\u0026#39;}; char32_t c32 {U\u0026#39;m\u0026#39;}; //early version wchar_t w {L\u0026#39;m\u0026#39;}; C++17 provides std::byte to handle byte type instead of using char type.\nstd::byte b { 42 }; Numerical Limits # C++ it’s recommended to use the std::numeric_limits class tem- plate defined in \u0026lt;limits\u0026gt;, instead of using #defines such as INT_MAX in C.\n//C++ standard cout \u0026lt;\u0026lt; \u0026#34;int:\\n\u0026#34;; cout \u0026lt;\u0026lt; format(\u0026#34;Max int value: {}\\n\u0026#34;, numeric_limits\u0026lt;int\u0026gt;::max()); cout \u0026lt;\u0026lt; format(\u0026#34;Min int value: {}\\n\u0026#34;, numeric_limits\u0026lt;int\u0026gt;::min()); cout \u0026lt;\u0026lt; format(\u0026#34;Lowest int value: {}\\n\u0026#34;, numeric_limits\u0026lt;int\u0026gt;::lowest()); cout \u0026lt;\u0026lt; \u0026#34;\\ndouble:\\n\u0026#34;; cout \u0026lt;\u0026lt; format(\u0026#34;Max double value: {}\\n\u0026#34;, numeric_limits\u0026lt;double\u0026gt;::max()); cout \u0026lt;\u0026lt; format(\u0026#34;Min double value: {}\\n\u0026#34;, numeric_limits\u0026lt;double\u0026gt;::min()); cout \u0026lt;\u0026lt; format(\u0026#34;Lowest double value: {}\\n\u0026#34;, numeric_limits\u0026lt;double\u0026gt;::lowest()); The output of this code snippet on my system is as follows:\nint: Max int value: 2147483647 Min int value: -2147483648 Lowest int value: -2147483648 double: Max double value: 1.79769e+308 Min double value: 2.22507e-308 Lowest double value: -1.79769e+308 Note the differences between min() and lowest(). For an integer, the minimum value equals the lowest value. However, for floating-point types, the minimum value is the smallest positive value that can be represented, while the lowest value is the most negative value representable, which equals -max().\n","date":"9 March 2023","permalink":"/posts/c++/c++20-programming/","section":"Posts","summary":"\u003cp\u003eThis article will introduce the programming of \u003cstrong\u003eC++20\u003c/strong\u003e, mainly focus on the \u003cstrong\u003eDifferences\u003c/strong\u003e between \u003cstrong\u003eC++ early version\u003c/strong\u003e and the \u003cstrong\u003eC++20\u003c/strong\u003e, also including some basic concepts of C++.\u003c/p\u003e","title":"C++20 Programming"},{"content":"","date":"12 January 2023","permalink":"/tags/javascript/","section":"Tags","summary":"","title":"Javascript"},{"content":"","date":"12 January 2023","permalink":"/categories/javascript/","section":"Categories","summary":"","title":"Javascript"},{"content":"This chapter will introduce the basic concept of Javascript and basic rules include grammar, variable, function and so on.\nIntroduction # JavaScript is a cross-platform, object-oriented scripting language used to make webpages interactive (e.g., having complex animations, clickable buttons, popup menus, etc.). There are also more advanced server side versions of JavaScript such as Node.js, which allow you to add more functionality to a website than downloading files (such as realtime collaboration between multiple computers). Inside a host environment (for example, a web browser), JavaScript can be connected to the objects of its environment to provide programmatic control over them.\nUsage # The usage of Javascript can be divided into INSIDE OF HTML and OUTSIDE OF HTML\nInside of HTML # For inside of HTML, Javascript must be placed between \u0026lt;script\u0026gt; and \u0026lt;/script\u0026gt;. And that should be located in \u0026lt;body\u0026gt; or \u0026lt;head\u0026gt; label or both of them.\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; document.write(\u0026#34;\u0026lt;h1\u0026gt;this is a theme\u0026lt;/h1\u0026gt;\u0026#34;); // this is a theme document.write(\u0026#34;\u0026lt;p\u0026gt;this is a paragraph\u0026lt;/p\u0026gt;\u0026#34;); // this is a paragraph \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Outside of HTML # Javascript can be separated from HTML as a independent file named .js. .js file can be imported in html between \u0026lt;script\u0026gt; by assign src same as inside of HTML.\n// myScript.js file function myFunction() { document.getElementById(\u0026#34;demo\u0026#34;).innerHTML=\u0026#34;helle world\u0026#34;; } \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script src=\u0026#34;myScript.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- hello world --\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Run in Chrome # Chrome browser is a good tool for debugging Javascript. For starting debug function, there are three ways.\nPress F12. Right-click and choose Check. Click More button, choose More tools, choose Developer tools. Debug in Console # You can directly write or copy code in Console window to debug it by press Enter.\nconsole.log(\u0026#34;hello world\u0026#34;) Debug in Snippets # You can also debug code by Snippets window by creating a new snippet. (Select the Sources window and click More button, you will find Snippets in new Chrome version.)\nCreate a new snippet, input your code, Ctrl + S (Windows and Linxe) or Command + S (Mac) to save the file, and then Right-click the file to run it.\nconsole.log(\u0026#34;hello world\u0026#34;) console.log(\u0026#34;my name is Kiona\u0026#34;) Output # Javascript itself doesn\u0026rsquo;t have any print or output function. Javascript can show data by four ways.\nwindows.alert() pop up window from browser. console.log() show in the browser console. document.write() write content into HTML document. innerHTML write content into HTML label. Window Alert # \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; window.alert(5 + 6); // pop up 11 from window alert \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Console Log # Only used for browser which support debug ability such as Chrome.\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; a = 5; b = 6; c = a + b; console.log(c); // show 11 in the debug console \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; HTML Document # Write the content into HTML document directly, and show in the browser.\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; document.write(Date()); // Thu Jan 12 2023 16:26:01 GMT+0800 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; HTML Label # Show the message by modifying the HTML label\u0026rsquo;s content.\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p id=\u0026#34;demo\u0026#34;\u0026gt;hello world\u0026lt;/p\u0026gt; \u0026lt;!-- \u0026#34;hello world\u0026#34; will be changed to \u0026#34;I\u0026#39;m Kiona\u0026#34; --\u0026gt; \u0026lt;script\u0026gt; document.getElementById(\u0026#34;demo\u0026#34;).innerHTML = \u0026#34;I\u0026#39;m Kiona\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Grammar # Literal # Literal is a element with solid value.\nLiteral Description Example Number Number is integer or decimal, or scientific count. (e/E) 3.14, 1001, 123e5 String String use double or single quotation as the mark. ('' or \u0026quot;\u0026quot;) \u0026quot;Kiona\u0026quot;, 'Kiona' Expression Expression is used for calculation 5+6, 5*6 Arry Arry is used for a set of data (support different types), and use middle bracket as the mark. ([]) [1, \u0026quot;hello\u0026quot;] Object Object is used to define a Key and its value. {class:\u0026quot;lion\u0026quot;, color:\u0026quot;yellow\u0026quot;, age:5} Function Function is used to define a function. function myFunction(a, b){return a*b;} Variable # Variable is different from literal, its value can be changed in any time. Javascript support a lot of data types (e.g. int, float, double, string) and you don\u0026rsquo;t need to specify data type in declaration.\nvar length = 16; var points = x * 10; var lastName = \u0026#34;Johnson\u0026#34;; var cars = [\u0026#34;Saab\u0026#34;, \u0026#34;Volvo\u0026#34;, \u0026#34;BMW\u0026#34;]; var person = {firstName:\u0026#34;John\u0026#34;, lastName:\u0026#34;Doe\u0026#34;}; Declaration # JavaScript has three kinds of variable declarations.\nvar declares a function-scoped or globally-scoped variable, optionally initializing it to a value. let declares a block-scoped local variable, optionally initializing it to a value. const creates block-scoped constants, much like variables declared using the let keyword. The value of a constant can\u0026rsquo;t be changed through reassignment and redeclared. (The detailed differences will be introduced in the follow chapter.) var x = 1; let y = \u0026#39;hello\u0026#39;; const z = [1, \u0026#39;hello\u0026#39;]; Operator # Javascript use Arithmetic Operators (+ - * /) and Assigning Operators (=) same like math method.\nvar x == (x + y) * 10; Javascript also have Bitwise Operator, Condition Operator, Comparison Operator and Logical Operator, which will be introduced in the follow chapter.\nSyntax # Javascript use ; to separate different statement.\nx = 5 + 6; y = x * 10; Function # Javascript use keyword \u0026ldquo;function\u0026rdquo; to define a function.\nfunction myFunction(a, b) { return a * b; } Keyword # Javascript keep a lot of keywords for build-in functions, which can not be used as custom element.\nabstract else instanceof super boolean enum int switch break export interface synchronized byte extends let this case false long throw catch final native throws char finally new transient class float null true const for package try continue function private typeof debugger goto protected var default if public void delete implements return volatile do import short while double in static with Comments # Javascript use double slash (// ) as the single line comments mark, and use (/* */) as the multiple lines comments mark.\n// this is the single line comments, which will not be considered as codes. /* this is the multiple lines comments mark */ Coding # JavaScript is Case-sensitive and uses the Unicode character set, which means it can supports such like:\nconst Früh = \u0026#34;foobar\u0026#34;; Variable # Variable is a container for mutable values or expressions.\nNaming rule # The name of variable observed follow rules:\nSupport number, alphabet, $, and _. Must start with alphabet or $ or _. Support Unicode character set. Case-sensitive. var x = 5; var y = 6; var z = x * y; var $name = \u0026#34;Kiona\u0026#34;; var Früh = \u0026#34;foobar\u0026#34;; Declarations # JavaScript has three kinds of variable declarations， and you don\u0026rsquo;t have to explicitly specify data type. But you still can use new to specify data type manually.\nvar name = new String; var x = new Number; var declares a function-scoped or globally-scoped variable, optionally initializing it to a value. var x = 1; if (x === 1) { var x = 2; // if use \u0026#39;let\u0026#39; the second output is 1 console.log(x); // expected output: 2 } console.log(x); // expected output: 2 let declares a block-scoped local variable, optionally initializing it to a value. let x = 1; if (x === 1) { let x = 2; /* if use var, it will result clash because of * existing global \u0026#39;x\u0026#39; and local \u0026#39;x\u0026#39; */ console.log(x); // expected output: 2 } console.log(x); // expected output: 1 const creates block-scoped constants, much like variables declared using the let keyword. The value of a constant can\u0026rsquo;t be changed through reassignment (i.e. by using the assignment operator), and it can\u0026rsquo;t be redeclared (i.e. through a variable declaration). However, if a constant is an object or array its properties or items can be updated or removed. const number = 42; try { number = 99; // if add \u0026#39;const\u0026#39;, it can be accepted and value is 99 } catch (err) { console.log(err); // expected output: TypeError: invalid assignment to const `number\u0026#39; // (Note: the exact output may be browser-dependent) } console.log(number); // expected output: 42 You can declare variables to unpack values using the destructuring assignment syntax. For example:\nconst { bar } = foo This will create a variable named bar and assign to it the value corresponding to the key of the same name from our object foo.\nVariables should always be declared before they are used. JavaScript used to allow assigning to undeclared variables, which creates an undeclared global variable. This is an error in strict mode and should be avoided altogether.\nInitialization # In var and let declarations, the initializer is optional. If a variable is declared without an initializer, it is assigned the value undefined.\nlet x; console.log(x); // logs \u0026#34;undefined\u0026#34; const declarations always need an initializer, because they forbid any kind of assignment after declaration, and implicitly initializing it with undefined is likely a programmer mistake.\nconst x; // SyntaxError: Missing initializer in const declaration Variable Scope # A variable may belong to one of the following scopes:\nGlobal scope: The default scope for all code running in script mode. Module scope: The scope for code running in module mode. Function scope: The scope created with a function. In addition, variables declared with let or const can belong to an additional scope:\nBlock scope: The scope created with a pair of curly braces ({}). Variable Hoisting # var declared variables are hoisted, meaning you can refer to the variable anywhere in its scope, even if its declaration isn\u0026rsquo;t reached yet. You can see var declarations as being \u0026ldquo;lifted\u0026rdquo; to the top of its function or global scope. However, if you access a variable before it\u0026rsquo;s declared, the value is always undefined, because only its declaration is hoisted, but not its initialization.\nconsole.log(x === undefined); // true var x = 3; (function() { console.log(x); // undefined var x = \u0026#39;local value\u0026#39;; })(); The above examples will be interpreted the same as:\nvar x; console.log(x === undefined); // true x = 3; (function() { var x; console.log(x); // undefined x = \u0026#39;local value\u0026#39;; })(); Notice if remove the sceond var in the first example, it will be:\nconsole.log(x === undefined); // true var x = 3; (function() { console.log(x); // 3 // because no new decalaration to be hoisted x = \u0026#39;local value\u0026#39;; })(); Because of hoisting, all var statements in a function should be placed as near to the top of the function as possible. This best practice increases the clarity of the code.\nBecause the variable is in a \u0026ldquo;temporal dead zone\u0026rdquo; from the start of the block until the declaration is processed, same situation for let and const will cause ReferenceError.\nconsole.log(x); // ReferenceError const x = 3; console.log(y); // ReferenceError let y = 3; Unlike var declarations, which only hoist the declaration but not its value, function declarations are hoisted entirely — you can safely call the function anywhere in its scope.\nUndeclared Variables # If you try to use a variable without declaration under Nonstrict-model, this value will belong to \u0026ldquo;window\u0026quot;\u0026rsquo;s a property to be accessed.\nvar var1 = 1; // unable to change var2 = 2; // belong to \u0026#39;window\u0026#39; can be changed console.log(this.var1); // 1 console.log(window.var1); // 1 console.log(window.var2); // 2 delete var1; // false can not be deleted console.log(var1); // 1 delete var2; console.log(delete var2); // true console.log(var2); // deleted, error: undefined Constants # You cannot declare a constant with the same name as a function or variable in the same scope. For example:\n// THIS WILL CAUSE AN ERROR function f() {}; const f = 5; // THIS WILL CAUSE AN ERROR TOO function f() { const g = 5; var g; //statements } However, const only prevents re-assignments, but doesn\u0026rsquo;t prevent mutations. The properties of objects assigned to constants are not protected, so the following statement is executed without problems.\nconst MY_OBJECT = { key: \u0026#39;value\u0026#39; }; MY_OBJECT.key = \u0026#39;otherValue\u0026#39;; Also, the contents of an array are not protected, so the following statement is executed without problems.\nconst MY_ARRAY = [\u0026#39;HTML\u0026#39;,\u0026#39;CSS\u0026#39;]; MY_ARRAY.push(\u0026#39;JAVASCRIPT\u0026#39;); console.log(MY_ARRAY); // [\u0026#39;HTML\u0026#39;, \u0026#39;CSS\u0026#39;, \u0026#39;JAVASCRIPT\u0026#39;]; Data Type # Javascript data type can be divided into two types: Primitive and Object.\nPrimitive Boolean, Null, Undefined, Number, String, Symbol Object Array, Object, Function, Date, Regex Javascript have dynamic types, which means same variable can represent different data type.\nvar x; // Undefined var x = 5; // Number var x = \u0026#34;John\u0026#34;; // String It can use typeof to check the variable data type.\ntypeof \u0026#34;John\u0026#34; // return String typeof 3.14 // return Number typeof false // return Boolean typeof [1,2,3,4] // return Object typeof {name:\u0026#39;John\u0026#39;, age:34} // return Object String # String is used to contain character set. The mark is \u0026quot; \u0026quot; or ' '.\nvar str = \u0026#34;hello world.\u0026#34;; var str = \u0026#39;hello world.\u0026#39;; The \u0026quot; \u0026quot; or ' ' can be nested, as long as they are pairs.\nvar str1 = \u0026#34;He is called \\\u0026#34;Kiona\\\u0026#34;\u0026#34;; var str2 = \u0026#39;He is called \u0026#34;Kiona\u0026#34;\u0026#39;; document.write(str1 + \u0026#34;\u0026lt;br\u0026gt;\u0026#34;) // He is called \u0026#34;Kiona\u0026#34; document.write(str2 + \u0026#34;\u0026lt;br\u0026gt;\u0026#34;) // He is called \u0026#34;Kiona\u0026#34; Number # Javascript have three ways to represent number.\nInteger without decimal point. Decimal with decimal point, which integer part can be omitted. Scientific Notation with exponent (e or E). var x = 1; var y = 3.14; var m = .325; // 0.325 var n = 498e-4; // 0.0498 Boolean # Boolean is a logical variable only support two values: true of false.\nvar flag = true; var mark = false; Array # Array is used to contain a set of values, and the types of these values can be different. Array, in fact, has two different means: Array Object and Array Literal.\nFor Array Object, you can create it by:\nvar arr = new Array(); arr[0] = \u0026#34;Kiona\u0026#34;; arr[1] = 1; arr[2] = true; Or use condensed way:\nvar arr = new Arry(\u0026#34;Kiona\u0026#34;, 1, true); For Array Literal, it is easy to create:\nvar arr = [\u0026#34;Kiona\u0026#34;, 1, true]; Arry will be discussed later for details.\nObject # An Object has its Key and corresponding Value, format is (Key : Value).\nvar person={name:\u0026#34;Kiona\u0026#34;, age:25, sex:male}; There are two ways to access these properties:\nvar name = person.name; var age = person[\u0026#34;age\u0026#34;]; Object will be discussed later for details.\nUndefined and Null # Undefined means the variable has not been assigned value. But Null means the value is null.\nvar x; // x is Undefined x = null; // x is null now Object # For Javascript almost every can be seen as Object. An Object has its Key and corresponding Value, format is (Key : Value). The mainly difference between Variable and Object is Variable only has one value, but Object can have arbitrary properties include their values.\nvar v1 = 163; // Variabel var car = {brand:\u0026#34;Toyota\u0026#34;, price:25e10, color:\u0026#34;red\u0026#34;}; // Object It can be said Object is a container of Variable, but this variable observed format Key : Value called as Property.\nThere are two ways to access Property:\nvar car = {brand:\u0026#34;Toyota\u0026#34;, price:25e10, color:\u0026#34;red\u0026#34;}; var brand = car.brand; var age = car[\u0026#34;age\u0026#34;]; Another difference is Function can be a member for Object as Property. You can use Object.Function() to access it, but if you omit \u0026ldquo;()\u0026rdquo;, it will print the code directly.\nvar obj = { myFunction : function(){ return \u0026#34;Kiona\u0026#34;; } } console.log(obj.myFunction()); // Kiona console.log(obj.myFunction); // function(){ return \u0026#34;Kiona\u0026#34;; } Function # Function is a code block which can be reused anytime. The grammar for defining a function is as follow, the ARGUMENT and return are not necessary, or you can just return without value:\nfunction FUNCTIONNAME(ARGUMENT1, ARGUMENT2,..., ARGUMENTN) { // code return RESULT; } The real values must strictly ordered same as the order of arguments, when call the Function.\nfunction add(x, y){ return x + y; } console.log(add(1, 2)); // 3 Local Variable # The space between double {} of Function called Local Space. When define variable inside local space by var, the life of this variable will end with the end of the function.\nfunction print(){ var str = \u0026#34;hello\u0026#34;; return str; } console.log(str); // error: str is undefined console.log(print()); // hello Global Variable # On the contrary, global space means space outside the function. Global variable can be accessed anytime untill the program end.\nvar str = \u0026#34;hello\u0026#34;; function print(){ console.log(str); } console.log(str); ","date":"12 January 2023","permalink":"/posts/javascript/javascript-basic/","section":"Posts","summary":"\u003cp\u003eThis chapter will introduce the basic concept of Javascript and basic rules include grammar, variable, function and so on.\u003c/p\u003e","title":"Javascript Basic"},{"content":"This chapter discusses what is JavaScript and its basic grammar, variable declarations, data types and literals.\nJavascript # JavaScript is a cross-platform, object-oriented scripting language used to make webpages interactive (e.g., having complex animations, clickable buttons, popup menus, etc.). There are also more advanced server side versions of JavaScript such as Node.js, which allow you to add more functionality to a website than downloading files (such as realtime collaboration between multiple computers). Inside a host environment (for example, a web browser), JavaScript can be connected to the objects of its environment to provide programmatic control over them.\nCoding # JavaScript is case-sensitive and uses the Unicode character set, which means it can supports such like:\nconst Früh = \u0026#34;foobar\u0026#34;; In JavaScript, instructions are called statements and are separated by semicolons (;).\nComments # The syntax of comments is the same as in C++ and in many other languages:\n// a one line comment /* this is a longer, * multi-line comment */ Variables # The names of variables in Javascript called identifiers, usually starts with a letter, underscore (_), or dollar sign ($). Subsequent characters can also be digits (0 – 9). Because JavaScript is case sensitive, letters include the characters A through Z (uppercase) as well as a through z (lowercase). Javascript also support ISO 8859-1 or Unicode letters such as å and ü in identifiers.\nSome examples of legal names are Number_hits, temp99, $credit, and _name.\nDeclarations # JavaScript has three kinds of variable declarations.\nvar declares a function-scoped or globally-scoped variable, optionally initializing it to a value. var x = 1; if (x === 1) { var x = 2; // if use \u0026#39;let\u0026#39; the second output is 1 console.log(x); // expected output: 2 } console.log(x); // expected output: 2 let declares a block-scoped local variable, optionally initializing it to a value. let x = 1; if (x === 1) { let x = 2; /* if use var, it will result clash because of * existing global \u0026#39;x\u0026#39; and local \u0026#39;x\u0026#39; */ console.log(x); // expected output: 2 } console.log(x); // expected output: 1 const creates block-scoped constants, much like variables declared using the let keyword. The value of a constant can\u0026rsquo;t be changed through reassignment (i.e. by using the assignment operator), and it can\u0026rsquo;t be redeclared (i.e. through a variable declaration). However, if a constant is an object or array its properties or items can be updated or removed. const number = 42; try { number = 99; // if add \u0026#39;const\u0026#39;, it can be accepted and value is 99 } catch (err) { console.log(err); // expected output: TypeError: invalid assignment to const `number\u0026#39; // (Note: the exact output may be browser-dependent) } console.log(number); // expected output: 42 You can declare variables to unpack values using the destructuring assignment syntax. For example:\nconst { bar } = foo This will create a variable named bar and assign to it the value corresponding to the key of the same name from our object foo.\nVariables should always be declared before they are used. JavaScript used to allow assigning to undeclared variables, which creates an undeclared global variable. This is an error in strict mode and should be avoided altogether.\nInitialization # In var and let declarations, the initializer is optional. If a variable is declared without an initializer, it is assigned the value undefined.\nlet x; console.log(x); // logs \u0026#34;undefined\u0026#34; const declarations always need an initializer, because they forbid any kind of assignment after declaration, and implicitly initializing it with undefined is likely a programmer mistake.\nconst x; // SyntaxError: Missing initializer in const declaration Variable scope # A variable may belong to one of the following scopes:\nGlobal scope: The default scope for all code running in script mode. Module scope: The scope for code running in module mode. Function scope: The scope created with a function. In addition, variables declared with let or const can belong to an additional scope:\nBlock scope: The scope created with a pair of curly braces ({}). Variable hoisting # var declared variables are hoisted, meaning you can refer to the variable anywhere in its scope, even if its declaration isn\u0026rsquo;t reached yet. You can see var declarations as being \u0026ldquo;lifted\u0026rdquo; to the top of its function or global scope. However, if you access a variable before it\u0026rsquo;s declared, the value is always undefined, because only its declaration is hoisted, but not its initialization.\nconsole.log(x === undefined); // true var x = 3; (function() { console.log(x); // undefined var x = \u0026#39;local value\u0026#39;; })(); The above examples will be interpreted the same as:\nvar x; console.log(x === undefined); // true x = 3; (function() { var x; console.log(x); // undefined x = \u0026#39;local value\u0026#39;; })(); Notice if remove the sceond var in the first example, it will be:\nconsole.log(x === undefined); // true var x = 3; (function() { console.log(x); // 3 // because no new decalaration to be hoisted x = \u0026#39;local value\u0026#39;; })(); Because of hoisting, all var statements in a function should be placed as near to the top of the function as possible. This best practice increases the clarity of the code.\nBecause the variable is in a \u0026ldquo;temporal dead zone\u0026rdquo; from the start of the block until the declaration is processed, same situation for let and const will cause ReferenceError.\nconsole.log(x); // ReferenceError const x = 3; console.log(y); // ReferenceError let y = 3; Unlike var declarations, which only hoist the declaration but not its value, function declarations are hoisted entirely — you can safely call the function anywhere in its scope.\nGlobal variables # Global variables are in fact properties of the global object.\nIn web pages, the global object is window, so you can set and access global variables using the window.variable syntax. In all environments, you can use the globalThis variable (which itself is a global variable) to access global variables.\nConsequently, you can access global variables declared in one window or frame from another window or frame by specifying the window or frame name.\nConstants # You cannot declare a constant with the same name as a function or variable in the same scope. For example:\n// THIS WILL CAUSE AN ERROR function f() {}; const f = 5; // THIS WILL CAUSE AN ERROR TOO function f() { const g = 5; var g; //statements } However, const only prevents re-assignments, but doesn\u0026rsquo;t prevent mutations. The properties of objects assigned to constants are not protected, so the following statement is executed without problems.\nconst MY_OBJECT = { key: \u0026#39;value\u0026#39; }; MY_OBJECT.key = \u0026#39;otherValue\u0026#39;; Also, the contents of an array are not protected, so the following statement is executed without problems.\nconst MY_ARRAY = [\u0026#39;HTML\u0026#39;,\u0026#39;CSS\u0026#39;]; MY_ARRAY.push(\u0026#39;JAVASCRIPT\u0026#39;); console.log(MY_ARRAY); // [\u0026#39;HTML\u0026#39;, \u0026#39;CSS\u0026#39;, \u0026#39;JAVASCRIPT\u0026#39;]; Data types # The latest ECMAScript standard defines eight data types:\nSeven data types that are primitives:\nBoolean. true and false. null. A special keyword denoting a null value. (Because JavaScript is case-sensitive, null is not the same as Null, NULL, or any other variant.) undefined. A top-level property whose value is not defined. Number. An integer or floating point number. For example: 42 or 3.14159. BigInt. An integer with arbitrary precision. For example: 9007199254740992n. String. A sequence of characters that represent a text value. For example: \u0026ldquo;Howdy\u0026rdquo;. Symbol. A data type whose instances are unique and immutable. and Object\nData type conversion # JavaScript is a dynamically typed language:\nlet answer = 42; And later, you could assign the same variable a string value, for example:\nanswer = \u0026#39;Thanks for all the fish!\u0026#39;; Numbers and the \u0026lsquo;+\u0026rsquo; operator # In expressions involving numeric and string values with the + operator, JavaScript converts numeric values to strings. For example:\nx = \u0026#39;The answer is \u0026#39; + 42 // \u0026#34;The answer is 42\u0026#34; y = 42 + \u0026#39; is the answer\u0026#39; // \u0026#34;42 is the answer\u0026#34; z = \u0026#39;37\u0026#39; + 7 // \u0026#34;377\u0026#34; With all other operators, JavaScript does not convert numeric values to strings. For example:\n\u0026#39;37\u0026#39; - 7 // 30 \u0026#39;37\u0026#39; * 7 // 259 Converting strings to numbers # In the case that a value representing a number is in memory as a string, there are methods for conversion.\nparseInt() parses a string argument and returns an integer of the specified radix. parseFloat() parses a string argument and returns a floating point number. parseInt(\u0026#39;101\u0026#39;, 2) // 5 An alternative method of retrieving a number from a string is with the + (unary plus) operator:\n\u0026#39;1.1\u0026#39; + \u0026#39;1.1\u0026#39; // \u0026#39;1.11.1\u0026#39; (+\u0026#39;1.1\u0026#39;) + (+\u0026#39;1.1\u0026#39;) // 2.2 // Note: the parentheses are added for clarity, not required. Array # The Array object, as with arrays in other programming languages, enables storing a collection of multiple items under a single variable name, and has members for performing common array operations.\nJavaScript arrays are resizable and can contain a mix of different data types. (When those characteristics are undesirable, use typed arrays instead.) JavaScript arrays are not associative arrays and so, array elements cannot be accessed using arbitrary strings as indexes, but must be accessed using nonnegative integers (or their respective string form, e.g., num[1] or num['1']) as indexes. JavaScript arrays are zero-indexed: the first element of an array is at index 0, the second is at index 1, and so on and the last element is at the value of the array\u0026rsquo;s length property minus 1. JavaScript array-copy operations create shallow copies. (All standard built-in copy operations with any JavaScript objects create shallow copies, rather than deep copies). Literals # Literals represent values in JavaScript. These are fixed values (not variables) that you literally provide in your script. This section describes the following types of literals:\nArray literals Boolean literals Numeric literals Object literals RegExp literals String literals Array literals # An array literal is a list of zero or more expressions, each of which represents an array element, enclosed in square brackets ([]). When you create an array using an array literal, it is initialized with the specified values as its elements, and its length is set to the number of arguments specified.\nconst coffees = [\u0026#39;French Roast\u0026#39;, \u0026#39;Colombian\u0026#39;, \u0026#39;Kona\u0026#39;]; // length is 3 Extra commas in array literals # If you put two commas in a row in an array literal, the array leaves an empty slot for the unspecified element.\nconst fish = [\u0026#39;Lion\u0026#39;, , \u0026#39;Angel\u0026#39;]; console.log(fish); // [ \u0026#39;Lion\u0026#39;, \u0026lt;1 empty item\u0026gt;, \u0026#39;Angel\u0026#39; ] Index-accessing fish[1] returns undefined, but which is not exactly the same as the actual undefined value.\nIn the following example, the length of the array is three. There is no myList[3].\nconst myList = [\u0026#39;home\u0026#39;, , \u0026#39;school\u0026#39;, ]; In the following example, the length of the array is four, and myList[0] and myList[2] are missing.\nconst myList = [, \u0026#39;home\u0026#39;, , \u0026#39;school\u0026#39;]; In the following example, the length of the array is four, and myList[1] and myList[3] are missing. Only the last comma is ignored.\nconst myList = [\u0026#39;home\u0026#39;, , \u0026#39;school\u0026#39;, , ]; However, when writing your own code, you should explicitly declare the missing elements as undefined, or at least insert a comment to highlight its absence.\nconst myList = [\u0026#39;home\u0026#39;, /* empty */, \u0026#39;school\u0026#39;, /* empty */, ]; Boolean literals # Do not confuse the Boolean primitive values true and false with the true and false values of the Boolean object.\nAny object, including a Boolean object whose value is false, evaluates to true when passed to a conditional statement. For example, the condition in the following if statement evaluates to true:\nconst x = new Boolean(false); if (x) { // this code is executed } This behavior does not apply to Boolean primitive. For example, the condition in the following if statement evaluates to false:\nconst x = false; if (x) { // this code is not executed } Do not use the Boolean() constructor with new to convert a non-boolean value to a boolean value. Use Boolean as a function or a double NOT (!!) instead:\nconst good = Boolean(expression); // use this const good2 = !!(expression); // or this const bad = new Boolean(expression); // don\u0026#39;t use this! If you specify any object, including a Boolean object whose value is false, as the initial value of a Boolean object, the new Boolean object has a value of true.\nconst myFalse = new Boolean(false); // initial value of false const g = Boolean(myFalse); // initial value of true const myString = new String(\u0026#39;Hello\u0026#39;); // string object const s = Boolean(myString); // initial value of true Numeric literals # JavaScript numeric literals include integer literals in different bases as well as floating-point literals in base-10.\nNote that the language specification requires numeric literals to be unsigned. Nevertheless, code fragments like -123.4 are fine, being interpreted as a unary - operator applied to the numeric literal 123.4.\nInteger literals # Integer and BigInt literals can be written in decimal (base 10), hexadecimal (base 16), octal (base 8) and binary (base 2).\nA decimal integer literal is a sequence of digits without a leading 0 (zero). A leading 0 (zero) on an integer literal, or a leading 0o (or 0O) indicates it is in octal. Octal integer literals can include only the digits 0 – 7. A leading 0x (or 0X) indicates a hexadecimal integer literal. Hexadecimal integers can include digits (0 – 9) and the letters a – f and A – F. (The case of a character does not change its value. Therefore: 0xa = 0xA = 10 and 0xf = 0xF = 15.) A leading 0b (or 0B) indicates a binary integer literal. Binary integer literals can only include the digits 0 and 1. A trailing n suffix on an integer literal indicates a BigInt literal. The integer literal can use any of the above bases. Note that leading-zero octal syntax like 0123n is not allowed, but 0o123n is fine. Some examples of integer literals are:\n0, 117, 123456789123456789n // decimal, base 10 015, 0001, 0o777777777777n // octal, base 8 0x1123, 0x00111, 0x123456789ABCDEFn // hexadecimal, \u0026#34;hex\u0026#34; or base 16 0b11, 0b0011, 0b11101001010101010101n // binary, base 2 Floating-point literals # Succinctly, the syntax is:\n[digits].[digits][(E|e)[(+|-)]digits] For example:\n3.1415926 .123456789 3.1E+12 .1e-23 Object literals # An object literal is a list of zero or more pairs of property names and associated values of an object, enclosed in curly braces ({}).\nUse (.) to access string property name. Use ([]) to access numeric property name. Use ([]) to access unvalid identifier property name. For example the car object:\n// e.g. 1 const sales = \u0026#39;Toyota\u0026#39;; function carTypes(name) { return name === \u0026#39;Honda\u0026#39; ? name : `Sorry, we don\u0026#39;t sell ${name}.`; } const car = { myCar: \u0026#39;Saturn\u0026#39;, getCar: carTypes(\u0026#39;Honda\u0026#39;), special: sales }; console.log(car.myCar); // Saturn console.log(car.getCar); // Honda console.log(car.special); // Toyota // e.g. 2 const car = { manyCars: { a: \u0026#39;Saab\u0026#39;, b: \u0026#39;Jeep\u0026#39; }, 7: \u0026#39;Mazda\u0026#39; }; console.log(car.manyCars.b); // Jeep console.log(car[7]); // Mazda // e.g. 3 const unusualPropertyNames = { \u0026#39;\u0026#39;: \u0026#39;An empty string\u0026#39;, \u0026#39;!\u0026#39;: \u0026#39;Bang!\u0026#39; } console.log(unusualPropertyNames[\u0026#39;\u0026#39;]); // An empty string console.log(unusualPropertyNames[\u0026#39;!\u0026#39;]); // Bang! Enhanced Object literals # Object literals support a range of shorthand syntaxes that include setting the prototype at construction, shorthand for foo: foo assignments, defining methods, making super calls, and computing property names with expressions.\nconst obj = { // __proto__ __proto__: theProtoObj, // Shorthand for \u0026#39;handler: handler\u0026#39; handler, // Methods toString() { // Super calls return \u0026#39;d \u0026#39; + super.toString(); }, // Computed (dynamic) property names [\u0026#39;prop_\u0026#39; + (() =\u0026gt; 42)()]: 42, } RegExp literals # A regex literal is a pattern enclosed between slashes (/).\nconst re = /ab+c/; String literals # A string literal is zero or more characters enclosed in double (\u0026quot;) or single (') quotation marks.\n\u0026#39;foo\u0026#39; \u0026#34;bar\u0026#34; \u0026#39;1234\u0026#39; \u0026#39;one line \\n another line\u0026#39; \u0026#34;Joyo\u0026#39;s cat\u0026#34; You should use string literals unless you specifically need to use a String object. See String for details on String objects.\nYou can call any of the String object\u0026rsquo;s methods on a string literal value. JavaScript automatically converts the string literal to a temporary String object, calls the method, then discards the temporary String object.\n// Will print the number of symbols in the string including whitespace. console.log(\u0026#34;Joyo\u0026#39;s cat\u0026#34;.length) // In this case, 10. Template literals # Template literals are enclosed by the back-tick ( `).\n// Basic literal string creation `In JavaScript \u0026#39;\\n\u0026#39; is a line-feed.` // Multiline strings `In JavaScript, template strings can run over multiple lines, but double and single quoted strings cannot.` // String interpolation const name = \u0026#39;Lev\u0026#39;, time = \u0026#39;today\u0026#39;; `Hello ${name}, how are you ${time}?` Tagged templates # Tagged templates are a compact syntax for specifying a template literal along with a call to a tag function for parsing it. A tagged template is just a more succinct and semantic way to invoke a function that processes a string and a set of relevant values. The name of the template tag function precedes the template literal — as in the following example, where the template tag function is named print. The print function will interpolate the arguments and serialize any objects or arrays that may come up, avoiding the pesky [object Object].\nconst formatArg = (arg) =\u0026gt; { if (Array.isArray(arg)) { // Print a bulleted list return arg.map((part) =\u0026gt; `- ${part}`).join(\u0026#34;\\n\u0026#34;); } if (arg.toString === Object.prototype.toString) { // This object will be serialized to \u0026#34;[object Object]\u0026#34;. // Let\u0026#39;s print something nicer. return JSON.stringify(arg); } return arg; } const print = (segments, ...args) =\u0026gt; { // For any well-formed template literal, there will always be N args and // (N+1) string segments. let message = segments[0]; segments.slice(1).forEach((segment, index) =\u0026gt; { message += formatArg(args[index]) + segment; }); console.log(message); } const todos = [ \u0026#34;Learn JavaScript\u0026#34;, \u0026#34;Learn Web APIs\u0026#34;, \u0026#34;Set up my website\u0026#34;, \u0026#34;Profit!\u0026#34;, ]; const progress = { javascript: 20, html: 50, css: 10 }; print`I need to do: ${todos} My current progress is: ${progress} `; // I need to do: // - Learn JavaScript // - Learn Web APIs // - Set up my website // - Profit! // My current progress is: {\u0026#34;javascript\u0026#34;:20,\u0026#34;html\u0026#34;:50,\u0026#34;css\u0026#34;:10} Since tagged template literals are just sugar of function calls, you can re-write the above as an equivalent function call:\nprint([\u0026#34;I need to do:\\n\u0026#34;, \u0026#34;\\nMy current progress is: \u0026#34;, \u0026#34;\\n\u0026#34;], todos, progress); This may be reminiscent of the console.log-style interpolation:\nconsole.log(\u0026#34;I need to do:\\n%o\\nMy current progress is: %o\\n\u0026#34;, todos, progress); Tagged template reads more naturally than a traditional \u0026ldquo;formatter\u0026rdquo; function, where the variables and the template itself have to be declared separately.\nEscape character # Character Meaning \\0 Null Byte \\b Backspace \\f Form Feed \\n New Line \\r Carriage Return \\t Tab \\v Vertical tab \\' Apostrophe or single quote \\\u0026quot; Double quote \\\\ Backslash character \\XXX The character with the Latin-1 encoding specified by up to three octal digits XXX between 0 and 377. For example, \\251 is the octal sequence for the copyright symbol. \\xXX The character with the Latin-1 encoding specified by the two hexadecimal digits XX between 00 and FF. For example, \\xA9 is the hexadecimal sequence for the copyright symbol. \\uXXXX The Unicode character specified by the four hexadecimal digits XXXX. For example, \\u00A9 is the Unicode sequence for the copyright symbol. \\u{XXXXX} Unicode code point escapes. For example, \\u{2F804} is the same as the simple Unicode escapes \\uD87E\\uDC04. const quote = \u0026#34;\\\\ He read \\\u0026#34;The Cremation of Sam McGee\\\u0026#34; by R.W. Service. \\\\\u0026#34;; console.log(quote); // \\ He read \u0026#34;The Cremation of Sam McGee\u0026#34; by R.W. Service. \\ You can also escape line breaks by preceding them with backslash. The backslash and line break are both removed from the value of the string.\nconst str = \u0026#39;this string \\ is broken \\ across multiple \\ lines.\u0026#39; console.log(str); // this string is broken across multiple lines. ","date":"9 January 2023","permalink":"/posts/javascript/javascript-basics-1/","section":"Posts","summary":"\u003cp\u003eThis chapter discusses what is JavaScript and its basic grammar, variable declarations, data types and literals.\u003c/p\u003e","title":"Javascript Basics 1"},{"content":"","date":"9 January 2023","permalink":"/tags/node.js/","section":"Tags","summary":"","title":"Node.js"},{"content":"This chapter will introduce the basic concept of Node.js and preparation for using Node.js.\nNode.js # Node.js is an open-source and cross-platform JavaScript runtime environment. Node.js runs the V8 JavaScript engine, the core of Google Chrome, outside of the browser. This allows Node.js to be very performant. Node.js can process every operation asynchronous in one single process, by a set of asynchronous I/O primitives privided in its standard library. Instead of creating a new thread, it\u0026rsquo;s easy to control. Node.js default use asynchronous functions, but also support synchronous functions which needed to be stated. Install Node.js # For Windows # It\u0026rsquo;s easy for installation of Node.js for Windows. Just download the proper installation package of Node.js from the Offical Link and install it.\nIt should be noticed that some useful modules can be installed automatically by Node.js. Just select \u0026lsquo;Automatically install the necessary tools.\u0026rsquo; when you install Node.js if you need these modules.\nAnd you can also install Node.js through Chocolatety (windows package management tool like apt in Linux), just run:\nchoco install Node.js By this way, it will not install additional modules automatically.\nFor Linux (e.g. Ubuntu) # You can also install Node.js by download the package from Offical Link, but it\u0026rsquo;s highly recommended installing by Linux Package Management tool e.g. apt.\nsudo install Node.js It should be noticed that compare with downloading installation package, some basic modules such as npm won\u0026rsquo;t be included automatically by this way. So you need to manually install them like:\nsudo apt install npm ","date":"9 January 2023","permalink":"/posts/nodejs/starting-nodejs/","section":"Posts","summary":"\u003cp\u003eThis chapter will introduce the basic concept of Node.js and preparation for using Node.js.\u003c/p\u003e","title":"Starting Node.js"},{"content":"","date":"29 December 2022","permalink":"/categories/lib/","section":"Categories","summary":"","title":"Lib"},{"content":"","date":"29 December 2022","permalink":"/categories/math/","section":"Categories","summary":"","title":"Math"},{"content":"","date":"29 December 2022","permalink":"/tags/petsc/","section":"Tags","summary":"","title":"PETSc"},{"content":"This article is the Usage for the two follow github projects about the use of PETSc lib.\nhttps://github.com/topopt/TopOpt_in_PETSc https://github.com/thsmit/TopOpt_in_PETSc_wrapped_in_Python The first project will be called TopOpt and the second is TopOptpy in the next part.\nInstallation of TopOpt # Installation # To clone the TopOpt:\ngit clone https://github.com/topopt/TopOpt_in_PETSc.git The main requirements are:\nLinux (tested in Ubuntu-22.04.1) PETSc (tested in 3.14.1 version) Check how to install PETSc in an other article\nAfter downloading the project, you will the file named makefile_ref in the root directory. The content of it is:\nPETSC_DIR=xxxxxx PETSC_ARCH=xxxxxx CFLAGS = -I. FFLAGS= CPPFLAGS=-I. FPPFLAGS= LOCDIR= EXAMPLESC= EXAMPLESF= MANSEC= CLEANFILES= NP= include ${PETSC_DIR}/lib/petsc/conf/variables include ${PETSC_DIR}/lib/petsc/conf/rules include ${PETSC_DIR}/lib/petsc/conf/test topopt: main.o TopOpt.o LinearElasticity.o MMA.o Filter.o PDEFilter.o MPIIO.o chkopts rm -rf topopt -${CLINKER} -o topopt main.o TopOpt.o LinearElasticity.o MMA.o Filter.o PDEFilter.o MPIIO.o ${PETSC_SYS_LIB} ${RM} main.o TopOpt.o LinearElasticity.o MMA.o Filter.o PDEFilter.o MPIIO.o rm -rf *.o myclean: rm -rf topopt *.o output* binary* log* makevtu.pyc Restart* Change the PETSC_DIR and PETSC_ARCH to your path (It can be found in the PETSc\u0026rsquo;s configure.log). And then, change the makefile_ref name to makefile, so you can make the project after that:\nmake check all Running # After making, you can do the following:\nNormal compilation time of framework, e.g. 4s: make topopt -j. Run the base example to generate bitwise file (.bat) by typing e.g.: mpirun -np 4 ./topopt. Postprocess results using Python 2.6 for visualization (.vtu): bin2vtu # where # refers to the iteration number If haven\u0026rsquo;t Python2.6, using sudo apt install python2 to install.\nThe result (default name output_xxxxx.vtu) can be visualized through Paraview, which can be installed by: sudo apt install paraview or download from https://www.paraview.org/. Running Paraview, open the output_xxxxx.vtu (File-\u0026gt;Open), turn on the eye button, and select one shader.\nInstallation of TopOptpy # o clone the TopOpt:\ngit clone https://github.com/thsmit/TopOpt_in_PETSc_wrapped_in_Python.git The main requirements are:\nLinux (tested in Ubuntu-22.04.1) PETSc (tested in 3.14.1 version) Python3 (tested in 3.10.6 version) One of the differents between TopOpt and TopOptpy is TopOptpy is managed by cmake. So before building, it need to install cmake by:\nsudo apt install cmake Then, set the PETSC_DIR and PETSC_ARCH path by:\nexport PETSC_ARCH=arch-linux-c-opt export PETSC_DIR=/home/ts/Documents/petsc And creat the build folder:\nmkdir build \u0026amp;\u0026amp; cd build At last, it can be maked:\ncmake .. -D PETSC_EXECUTABLE_RUNS=ON make -j $(nproc) When making the project, might meeting the error likes:\nCannot compile.link C with mpicc: /usr/bin/ld: cannot find -lmpi_cxx It means lack of depended libs. You need to use apt to install them for example:\nsudo apt search lmpi ... sudo apt install libmkl-blacs-intelmpi-ilp64 #Choose the applicable version Running # Running \u0026lsquo;hello world\u0026rsquo; example # Running a \u0026lsquo;hello world\u0026rsquo; example from the command line. Generates standard cantilever beam and output .vtr files for viewing in Paraview.\nimport topoptlib data = topoptlib.Data() data.solve() The output files are named TopOpt_xxx.vtr, which can be read as a group by Paraview same like TopOpt.\nRunning examples # To run the cantilever beam example on one CPU (adjust the problem\u0026rsquo;s mesh according to the number of available CPU\u0026rsquo;s):\ncd TopOpt_in_PETSc_wrapped_in_Python cp examples/beam.py . python3 beam.py Available examples:\nCantilever beam in beam.py Multi-loads in multiloads.py Torsion ball in sphere.py The Jet engine bracket in bracket.py Running on ETH Euler (without installing PETSc) # env2lmod module load gcc/4.8.5 cmake/3.16.5 openmpi/3.0.1 petsc/3.10.5 python/3.7.4 cd TopOpt_in_PETSc_wrapped_in_Python mkdir build cd build cmake .. make cd .. bsub -n 8 mpirun -n 8 python3 bracket.py Or use run_topopt.sh for automated building and running.\nRunning tests # Several tests are provided to verify the proper working of the framework. To run a test using 4 CPU\u0026rsquo;s use:\ncd TopOpt_in_PETSc_wrapped_in_Python cp topoptlib/test/test_beam.py . mpirun -n 4 python3 test_beam.py Implemented tests in /tests:\nTesting standard MBB problem with maxItr of 40 test_beam.py Testing the standard MBB problem with two line loads test_multiload.py Testing continuation of penalization test_continuation.py Testing heavyside projection filtering test_projection.py Testing stl readin of design domain, rigid domain test_sphere.py Testing stl readin of design domain, rigid domain test_bracket.py Testing the robust approach test_michell.py Or use test_topopt.sh for automated building and running the tests. Post-processing (easy) # The framework can write .vtr files of the designs with in point data. The designs can be viewed in Paraview. The point data can be transformed into cell data by using Paraview\u0026rsquo;s PointToCellData filter. To generate .vtr files add the following command to the problem definition:\nvtr(20) Post-processing (original) # After solving the problem the output is written to a output.dat file. The designs can be viewed in Paraview. To generate .vtu files from the output file use post_process_topopt.sh with Python 2 (with * the file path and name where the output file is stored):\ncd TopOpt_in_PETSc_wrapped_in_Python ./post_process_topopt.sh * ","date":"29 December 2022","permalink":"/posts/petsc/topopt-in-petsc/","section":"Posts","summary":"\u003cp\u003eThis article is the Usage for the two follow github projects about the use of PETSc lib.\u003c/p\u003e","title":"Usage of TopOpt-in-PETSc Projects"},{"content":"This article will cover the installation of the PETSc library, including the common installation for Linux and the attempt on Windows.\nInstallation for Linux # This article is applicable to the building of PETSc-3.14.1. You can download the newest version by:\ngit clone -b release https://gitlab.com/petsc/petsc.git #If haven\u0026#39;t the git tool, you can install it through \u0026#39;apt\u0026#39;. #Follow steps will show how to use \u0026#39;apt\u0026#39;. or search the applicable version through the link:\nhttps://gitlab.com/petsc/petsc\nEnvironment # Building PETSc relies on the following environments：\nUbuntu (Linux system, tested in 22.04.1 version) gcc/g++/gfrotran (C/C++/Frotran compiler, tested in 11.3.0 version) Python3 (tested in 3.10.6) LAPACK/BLAS (Scientific computing library, tested in 3,4,2 version) MPICH (Realization of MPI, tested in 4.0.2 version) Installation # The first step is installing Ubuntu system, you can install it on your PC or virtual machine (e.g.VMware).\nPlease choose English as the system language if you can accpet, which is convenient for programming. You can choose the minimal installation and don\u0026rsquo;t choose any third-part software and updating opeions when installing, if you internet is not good enough. After Ubuntu installation, the first thing you need to do is updating software. Ubuntu uses apt gizmo to manage software, the updating command:\n# Using \u0026#39;apt-get\u0026#39; to instead \u0026#39;apt\u0026#39;, If your system doesn\u0026#39;t support \u0026#39;apt\u0026#39; sudo apt update # update \u0026#39;apt\u0026#39; itself sudo apt upgrade # update software If the origin software mirror source is too late, you can change it by:\ncp /etc/apt/sources.list /etc/apt/sources.list.bak # Copy old version sudo vi /etc/apt/sources.list deb http://mirrors.aliyun.com/ubuntu/ xxxx main restricted universe multiverse # Change all the link, notice keep \u0026#39;xxxx\u0026#39; with your own Codename Some recommended sources are follows:\n# Aliyun deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse # Tsinghua deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse The next step is installing gcc/g++/gfrotran and Python3, you can directly install them with apt:\nsudo apt install gcc sudo apt install g++ sudo apt install gfortran sudo apt install python3 If can\u0026rsquo;t find the package, you can use apt search to search it and choose the right version for installing.\nIn some situation, you might meet error: configure: error: no acceptable C compiler found in $PATH, especially choosing minimal version when installing Ubuntu. You can fix it by:sudo apt-get install -y build-essential.\nThere are two different ways about installing LAPACK/BLAS and MPICH. The first is installing during the PETSc configuring, which recommended by PETSc official. The other is using apt.\nFor the first way, cd into the PETSc\u0026rsquo;s root directory and configure with follow command:\n./configure --with-cc=gcc --with-cxx=g++ --with-fc=gfortran --download-mpich --download-fblaslapack If download fails, you can download these packages mannually from the given link in the configure message. Then, indicate the download directory:\n./configure --with-cc=gcc --with-cxx=g++ --with-fc=gfortran --download-mpich --download-fblaslapack --with-download-dir=\u0026lt;xxxxx\u0026gt; After configuration, make the project:\nmake all check If you don\u0026rsquo;t have the make tool, install it by apt.\nThe second way is installing LAPACK/BLAS and MPICH mannually. LAPACK/BLAS are easily to install:\nsudo apt search lapack-dev ... sudo apt install liblapack64-dev #Choose the applicable version sudo apt search blas-dev ... sudo apt install libblas64-dev #Choose the applicable version MPI is a cross-language communication protocol for parallel programming. MPICH is one of realizations of MPI, and you can also choose OpenMPI to instead it:\nsudo apt install mpich #sudo apt install openmpi After that, if the $PATH is correct you can configure PETSc directly, otherwise you need indicate the directory:\n./configure --with-cc=gcc --with-cxx=g++ --with-fc=gfortran #./configure --with-cc=gcc --with-cxx=g++ --with-fc=gfortran --with--mpich-dir=\u0026lt;xxxx\u0026gt; --with--fblaslapack-dir=\u0026lt;xxxx\u0026gt; After configuration, make the project:\nmake all check During the making process, some errors might occur such as /usr/bin/ld: cannot find -lmpi_cxx, which means lack of depended libs. You need to use apt to install them for example:\nsudo apt search lmpi ... sudo apt install libmkl-blacs-intelmpi-ilp64 #Choose the applicable version After making, the message will show follows. You can re-check this information through configure.log, the PETSC_DIR and PETSC_ARCH will be used in your project.\n----------------------------------------- PETSC_VERSION_RELEASE . . . ----------------------------------------- #define SOME_PETSC_VARIABLE . . . ----------------------------------------- Installed Compiler, Package, and Library Information . . . ========================================= FC arch-darwin-c-debug/obj/sys/f90-mod/petscsysmod.o FC arch-darwin-c-debug/obj/sys/fsrc/somefort.o FC arch-darwin-c-debug/obj/sys/f90-src/fsrc/f90_fwrap.o CC arch-darwin-c-debug/obj/sys/info/verboseinfo.o CC arch-darwin-c-debug/obj/sys/info/ftn-auto/verboseinfof.o CC arch-darwin-c-debug/obj/sys/info/ftn-custom/zverboseinfof.o . . . FC arch-darwin-c-debug/obj/snes/f90-mod/petscsnesmod.o FC arch-darwin-c-debug/obj/ts/f90-mod/petsctsmod.o FC arch-darwin-c-debug/obj/tao/f90-mod/petsctaomod.o CLINKER arch-darwin-c-debug/lib/libpetsc.PETSC_MAJOR.PETSC_MINOR.PETSC_PATCH.dylib DSYMUTIL arch-darwin-c-debug/lib/libpetsc.PETSC_MAJOR.PETSC_MINOR.PETSC_PATCH.dylib gmake[2]: Leaving directory \u0026#39;/your/petsc/dir\u0026#39; gmake[1]: Leaving directory \u0026#39;/your/petsc/dir\u0026#39; ========================================= Running test examples to verify correct installation Using PETSC_DIR=/your/petsc/dir and PETSC_ARCH=your-petsc-arch C/C++ example src/snes/examples/tutorials/ex19 run successfully with 1 MPI process C/C++ example src/snes/examples/tutorials/ex19 run successfully with 2 MPI processes Fortran example src/snes/examples/tutorials/ex5f run successfully with 1 MPI process Completed test examples Installation for Windows # The installation of PETSc for Windows is not successful yet, this is just a record for the works.\nEnvironment # This article try MSYS2 and Cygwin separately to build PETSc：\nMSYS2 (Linux environment in Windows, tested in 20221216.0.0 version) Cygwin (Linux environment in Windows, tested in 1.2.1 version) Test in MSYS2 # The MSYS2 system uses pacman to manage packages such like apt. You need to install all the same packages in Linux to MSYS2 by pacman. MSYS2 doesn\u0026rsquo;t have some base packages (e.g.make), which you also need to install. Usage of pacman:\npacman -Ss [package name] #Search package pacman -S [package name] #Install package The problem is when trying to configure PETSc after installing all the packages, it will meet error:\nCould not execute \u0026#34;[\u0026#39;/bin/rpm -q diffutils\u0026#39;]\u0026#34;: /bin/sh: line 1: /bin/rpm: No such file or directory. The MSYS2 is a simple Linux environment running on Windows, which doesn\u0026rsquo;t support enough to run this command.\nTest in Cygwin # The Cygwin system doesn\u0026rsquo;t have such as pacman or apt tool to manage packages. One of the way to get package is to re-run the Cygwin-setup and to choose the needed package.\nThe other way to get the package is use apt-cyg. apt-cyg is similar to apt, but need be installed mannually:\nlynx -source rawgit.com/transcode-open/apt-cyg/master/apt-cyg \u0026gt; apt-cyg install apt-cyg /bin Or you can copy the apt-cyg\u0026rsquo;s content through https://github.com/transcode-open/apt-cyg to Cygwin:/bin to creat the same file and run:\nchmod +x apt-cyg The first problem except installing the base packages is Cygwin can\u0026rsquo;t install MPICH successfully through above ways. So I try to build it mannualy.\nFirstly, download the source of MPICH from https://www.mpich.org/downloads/ and unpack the tar file (If doesn\u0026rsquo;t have tar or other tools, just install them by Cygwin-setup or apt-cyg):\ntar xfz mpich.tar.gz #If tar doesn’t accept the z option, use #gunzip -c mpich.tar.gz | tar xf - Let us assume that the directory where you do this is /home/you/libraries. It will now contain a subdirectory named mpich-x.x.x. Choose an installation directory (the default is /usr/local/bin):\nmkdir /home/you/mpich-install Choose a build directory:\nmkdir /tmp/you/mpich-x.x.x Configure MPICH, specifying the installation directory, and running the configure script in the source directory:\ncd /tmp/you/mpich-x.x.x /home/you/libraries/mpich-x.x.x/configure -prefix=/home/you/mpich-install |\u0026amp; tee c.txt For the Cygwin\u0026rsquo;s gfortran, it will meet error:\nconfigure: error: The Fortran compiler gfortran does not accept programs that call the same routine with arguments of different types without the option -fallow-argument-mismatch. Rerun configure with FFLAGS=-fallow-argument-mismatch and FCFLAGS=-fallow-argument-mismatch Change the command:\n/home/you/libraries/mpich-x.x.x/configure -prefix=/home/you/mpich-install FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch |\u0026amp; tee c.txt The error change to:\nconfigure: error: libfabric only builds on Linux, OS X, and FreeBSD configure: error: libfabric configure failed It seems Cygwin can not support MPICH yet.\nConclusion # It is not to hard to and possible to change the code to Windows version, because of the similarity between gcc and MSVC。So the best way is to rewrite the full code instead of using virtual Linux environment.\n","date":"28 December 2022","permalink":"/posts/petsc/installation-petsc/","section":"Posts","summary":"\u003cp\u003eThis article will cover the installation of the PETSc library, including the common installation for Linux and the attempt on Windows.\u003c/p\u003e","title":"Installation of PETSc"},{"content":"","date":"1 January 0001","permalink":"/archive/","section":"","summary":"","title":"Archive"},{"content":"","date":"1 January 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":" ⚓ # ⚓ O virgo, just do the right thing S.\n🌞 我的 MINE\nmineitem one mineitem two mineitem three 🔨 工具 TOOLs\ntoolitem three 📑 文档 DOCs\ndocitem one docitem two docitem three 🍺 博客 BLOGs\nblogitem one blogitem two blogitem three 🎉 休闲 LEISURE\nleisureitem one leisureitem three 🎧 影视 MOVIEs\nmovieitem one movieitem three 🧲 友链 LINKs\nnavitem two navitem three 🔖 # 🔖 Bookmarks InboX\nbookmark item one https://bookmark-item-one.com bookmark item two https://bookmark-item-two.com bookmark item three https://bookmark-item-three.com ","date":"1 January 0001","permalink":"/nav/","section":"","summary":"⚓ # ⚓ O virgo, just do the right thing S.","title":"Nav"},{"content":"","date":"1 January 0001","permalink":"/search/","section":"","summary":"","title":"Search"},{"content":"","date":"1 January 0001","permalink":"/series/","section":"Series","summary":"","title":"Series"}]